[{"title":"three.js简单分享","url":"/2022/09/04/threejs%E7%AE%80%E5%8D%95%E5%88%86%E4%BA%AB/","content":"了解three.js简介three.js是使用js语言写的一个3D库。在浏览器端，有个叫做WebGL的底层标准，这个标准被定义后，浏览器就实现了这个标准，然后就能通过js在网页上来实现三维图形的渲染。threejs就是封装了底层的图形接口，让开发更易实现3D程序\n核心WebGL的渲染需要HTML的Canvas，所以渲染的3D内容都是需要在canvas元素里。一个threejs程序至少包括渲染器(Renderer)、场景(Scene)、照相机(Camera)、以及在场景里创建的各种物体。\n渲染器渲染器的作用是使用WebGLRender对象，调用计算机的显卡来渲染所需要的显示的东西，包括灯光，背景，几何体等等。它需要和Canvas绑定，threejs也可以生成Canvas，代码如下：\n//初始化渲染器function initRenderer() &#123;  let renderer;  renderer = new THREE.WebGLRenderer(); //实例化渲染器  renderer.setSize(window.innerWidth, window.innerHeight); //设置宽和高  document.body.appendChild(renderer.domElement); //添加到dom&#125;\n\n场景在threejs中添加的物体都是添加到场景中的，所以说，场景就相当于一个大容器，在程序最开始的时候进行实例化场景，然后再往场景中添加物体。代码如下：\n//初始化场景function initScene() &#123;  let scene;  scene = new THREE.Scene(); //实例化场景&#125;\n也就是说场景是光源，相机，所有物体的父容器。\n相机WebGL和threejs用的坐标是右手坐标系，右手伸出，手心朝向自己，大拇指朝向是X轴，四指为Y轴，手心朝向是Z轴。在threejs中一般用的比较多的是透视相机(THREE.PerspectiveCamera)，就像人的眼睛一样，看到的东西有“近大远小”的感官效果THREE.PerspectiveCamera构造函数有四个参数，分别是fov, aspect, near, farfov：视角大小，如果设置为0，就相当于闭上了眼睛，值越大，视角越宽。aspect：为实际窗口的纵横比，即宽度除以高度。near：为距离相机最近的临界点，物体和相机距离低于这个值，物体就看不到了。far： 为距离相机最远的临界点，物体和相机距离大于这个值，物体也就看不到了。\n如下代码，视角为45°，纵横比为窗口宽度除以窗口高度，物体的可视距离为0.1~200。\n//初始化相机function initCamera() &#123;  let camera;  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200); //实例化相机  camera.position.set(0, 0, 15);&#125;\n\n创建模型形状threejs封装了一些常见的几何体，使用时只需要定义好值就行，THREE.BoxGeometry是封装好的立方体，有三个参数分别是width：X方向的长度，height：Y方向长度，depth：Z方向的长度\n材质材质是与渲染效果相关的属性，通过改变材质可以改变物体的颜色，纹理贴图，光照模式等\n物体最常见的一种物体就是网格(Mesh)，网格是由顶点，边，面等组成的物体，其他物体包括线段，骨骼，粒子系统等创建物体需要指定几何形状和材质。代码如下,创建了个长宽高为2的立方体，材质为Phong材质，考虑了镜面反射的效果，创建了一个包含如上形状和材质的物体，添加到场景中。\n//创建模型function initMesh() &#123;  geometry = new THREE.BoxGeometry(2, 2, 2); //创建几何体  material = new THREE.MeshNormalMaterial(); //创建材质  mesh = new THREE.Mesh(geometry, material); //创建网格  scene.add(mesh); //将网格添加到场景&#125;\n\n动作渲染一般无限循环的动作可用requestAnimationFrame循环来不停渲染如下代码，使用requestAnimationFrame，收集每一帧的dom变化，然后以每秒60帧的频率重绘dom。每帧网格模型沿x轴旋转0.01弧度，沿y轴旋转0.02弧度。\n//运行动画function animate() &#123;  requestAnimationFrame(animate); //循环调用函数  mesh.rotation.x += 0.01; //每帧网格模型的沿x轴旋转0.01弧度  mesh.rotation.y += 0.02; //每帧网格模型的沿y轴旋转0.02弧度  renderer.render(scene, camera); //渲染界面&#125;\n\n灯光threejs中有很多种光源，环境光、点光源、聚光灯、平行光如下代码，使用点光源，\nTHREE.PointLight(hex, intensity, distance)\n其中， hex 是光源十六进制的颜色值； intensity 是亮度，默认值为 1 ，表示 100%亮度； distance 是光源最远照射到的距离，默认值为 0 。\n//创建光源function initLight() &#123;  light = new THREE.PointLight(0xffffff, 2, 100);   //创建点光源  light.position.set(10, 10, 10);  scene.add(light);&#125;\n\n例子结合上述知识点，简单画了个立方体，使用点光源照射，采用了Phong 材质，Phong 模型考虑了镜面反射的效果，因此对于金属、镜面的表现尤为适合，沿x轴旋转0.01弧度，y轴旋转0.02弧度不停旋转。\n","tags":["three.js"]},{"title":"我的老婆顾宇婷","url":"/2022/07/26/%E6%88%91%E7%9A%84%E8%80%81%E5%A9%86%E9%A1%BE%E5%AE%87%E5%A9%B7/","content":"姓名：顾宇婷她是只猪这是她写的代码\nlet xx = &#x27;hello&#x27;xx = xx + &#x27;world&#x27;\n","tags":["日常"]},{"title":"重构简单笔记","url":"/2022/09/08/%E9%87%8D%E6%9E%84%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/","content":"重构的定义所谓重构是这样一个过程：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度地减小整理过程中引入错误的概率。本质上说，重构就是在代码写好之后改进它的设计。\n代码的坏味道简单来说，就是碰到什么样子的代码，就需要警惕起来，需要进行重构了。下面是一部分的有问题的代码举例\n\n神秘命名比如一些像abc随意命名的代码或者汉语拼音，总之一切看不懂的命名\n\n重复代码只要是我们看到两段相似的语法都可以确定为这段代码可以提炼，通常提炼出来会更好，当然这个要看具体情况，个人感觉真的遇到那种只有两处，且代码使用地方八杆子打不着，在代码稳定期间也不用浪费这个时间。可以通过提炼函数等手法重构\n\n过长的函数比如一些条件分支、一个函数做了很多事情、循环内的处理等等的都是应该重构的。可以通过提炼函数等手法。\n\n循环语句传统的for循环。可以用管道来取代循环例如JS中的map、forEach、reduce、filter等一系列。\n\n临时字段那些本身就足以说明自己是谁的，不需要名字来描述的。提炼函数。\n\n\n重构的手法提炼函数时机：当我们觉得一段大函数内某一部分代码在做的事情是同一件事，并且自成体系，不与其他掺杂时当代码展示的意图和真正想做的事情不是同一件时候，如作者提到的例子。想要高亮，代码意思为反色，这样就不容易让人误解。做法：一个以他要做什么事情来命名的函数待提炼代码复制到这个函数检查这个函数内的代码的作用域、变量编译查看函数内有没有报错（js可以通过eslint协助）替换源函数的被提炼代码替换为函数调用测试替换其他代码中是否有与被提炼的代码相同或相似之处\n提炼变量时机：一段又臭又长的表达式在多处地方使用这个值（可能是当前函数、当前类乃至于更大的如全局作用域）做法：确保要提炼的表达式，对其他地方没有影响声明一个不可修改的变量，并用表达式作为该变量的值用新变量取代原来的表达式测试交替使用3、4\n例子，计算一批商品的总额，销量超过500，超出部分打9.5折，每件商品的运费为售价的10%，总运费不超过100\n//重构前return order.quantity * order.itemPrice -     Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +    Math.min(order.quantity * order.itemPrice * 0.1, 100);//重构后const basePrice = order.quantity * order.itemPrice;const  quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;const shipping = Math.min(order.quantity * order.itemPrice * 0.1, 100);return basePrice - quantityDiscount  + shipping\n\n以查询取代临时变量时机：修改对象最好是一个类有很多函数都在将同一个值作为参数传递分解过长的冗余函数多个函数中重复编写计算逻辑，比如讲一个值进行转换（好几个函数内都需要这个转换函数）如果这个值被多次修改，应该将这些计算代码一并提炼到取值函数做法：检查是否每次计算过程和结果都一致(不一致则放弃)如果能改为只读，就改成只读将变量赋值取值提炼成函数测试去掉临时变量\n以函数调用替换内联代码时机：函数内做的某些事情与已有函数重复已有函数与函数之间希望同步变更做法：内联代码替换为函数（可能有参数,就要对应传递）\n以管道替代循环时机：一组虽然在做相同事情的循环，但是内部过多的处理逻辑，使其晦涩难懂做法：创建一个新变量，用来存放每次行为处理后，参与循环的剩余集合选用合适的管道，将每一次循环的行为进行搬移搬移完所有的循环行为，删除整个循环\n例子，有一个CSV文件，里面存有各个办公室（office）的一些数据\noffice, country, telephone Chicago, USA, +1 312 373 1000Beijing, China, +86 4008 900 505Bangalore, India, +91 80 4064 9570Porto Alegre, Brazil, +55 51 3079 3550Chennai, India, +91 44 660 44766\n下面这个acquireData函数的作用是从数据中筛选出印度的所有办公室，并返回办公室所在的城市（city）信息和联系电话（telephone number）。\nfunction acquireData(input) &#123; 　const lines = input.split(&quot;\\n&quot;);　let firstLine = true;　const result = [];　for (const line of lines) &#123;　　if (firstLine) &#123;　　　firstLine = false; 　　　continue;　　&#125;　　if (line.trim() === &quot;&quot;) continue; 　　const record = line.split(&quot;,&quot;);　　if (record[1].trim() === &quot;India&quot;) &#123;　　　result.push(&#123;city: record[0].trim(), phone: record[2].trim()&#125;);　　&#125;　&#125;　return result;&#125;\n这个循环略显复杂，所以可以用管道来替换它\nfunction acquireData(input) &#123; 　const lines = input.split(&quot;\\n&quot;); 　return lines　　　　.slice (1)　　　　.filter (line =&gt; line.trim() !== &quot;&quot;)　　　　.map   (line =&gt; line.split(&quot;,&quot;))　　　　.filter (fields =&gt; fields[1].trim() === &quot;India&quot;)　　　　.map   (fields =&gt; (&#123;city: fields[0].trim(), phone: fields[2].trim()&#125;))　　　　;&#125;\n\n","tags":["阅读","重构"]}]